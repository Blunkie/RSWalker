{==============================================================================]
  Author: Jarl K. Holta
  Project: RSWalker 
  Project URL: https://github.com/WarPie/RSWalker
  License: GNU GPL (http://www.gnu.org/licenses/gpl.html)
[==============================================================================}
{$loadlib ../Includes/RSWalker/libWalker.dll}
{$include_once MatchTempl.pas}
{$include_once MemScan.pas}
{$include_once Utilities.pas}
{$include_once Base.pas}

type
  TOnWalkEvent = procedure(sender:TObject; myPos: TPoint);
  TOnMoveEvent = procedure(sender:TObject; myPos: TPoint);
  
  TRSWalker = record
    WorldMap, worldSample: T2DIntArray;
    SkipClose: Int32;
    MinRunEnergy: Int32;
    
    Finder: TRSPosFinder;
    MemScanEnabled: Boolean;
    LocalMap: T2DIntArray;
    Global: TPoint;

    FPath: TPointArray;
    FPathIdx: Int32;

    onWalkEvent: TOnWalkEvent;
    onMoveEvent: TOnMoveEvent;
    
    Enabled:Boolean;
  end;


{$IFNDEF CodeInsight}
procedure TRSWalker.SetDefaultValues();
begin
  onWalkEvent  := nil;
  onMoveEvent  := nil;

  skipClose   := 10;
  minRunEnergy:= 20;
  
  memScanEnabled := True;
  enabled := True;
end;


function TRSWalker.TryGetClientID(): UInt32;
var
  H:PtrUInt;
begin
  {$IFDEF SMART}
    Result := SMART.PID;
  {$ELSE}
    H := Client.GetIOManager().GetKeyMouseTarget().GetHandle();
    Result := GetWindowProcessID(H);
  {$ENDIF}
end;
{$ENDIF}


procedure TRSWalker.Init(World: String; PID:Int32=0; AScanRatio:Int32=8);
var
  BMP:Integer;

  function FindMapPath(path:String): String;
  var
    testPath:String;
  begin
    Result := path;
    if not FileExists(result) then
    begin
      testPath := IncludePath+'RSWalker\maps\'+result
      if (not FileExists(testPath)) then
        RaiseException(erException, 'TRSWalker.Init -> Map `'+result+'` not found');
      Result := testPath;
    end;
  end;
begin
  with self do
  begin
    if (PID = 0) then PID := self.TryGetClientID();
    finder.Init(PID);
    finder.scanRatio := AScanRatio;

    self.SetDefaultValues();
    
    if world <> '' then
    begin
      BMP := LoadBitmap(FindMapPath(world));
      worldMap := BitmapToMatrix(BMP);
      FreeBitmap(BMP);
      worldSample := w_imSample(worldMap, finder.scanRatio);
    end else
      self.enabled := False;
  end;
end;


procedure TRSWalker.Free();
begin
  finder.Free();
  setLength(worldMap, 0);
  setLength(worldSample, 0);
  setLength(localMap, 0);
end;

{---| IF MEMSCAN |---]
  Changes the state of MemScan (use, or not use)
}
function TRSWalker.ToggleMemScan(): Boolean;
begin
  memScanEnabled := not memScanEnabled;
  Result := memScanEnabled and (finder.process > 0); 
end;


{---| IF MEMSCAN |---]
  Locates the current minimap in the world map
}
function TRSWalker.FindChunk(pt:TPoint; area:Int32=100): TPoint;
var
  loc,locSample:T2DIntArray;
  corr:T2DFloatArray;
  B:TBox;
  shift:TPoint;
begin
  B := [pt.x-area, pt.y-area, pt.x+area, pt.y+area];
  B := [max(52,B.x1),max(52,B.y1),min(459,B.x2),min(459,B.y2)];
  loc := w_GetArea(self.localMap, b.x1,b.y1,b.x2,b.y2);
  locSample := w_ImSample(loc, Finder.scanRatio);
  shift := Point(pt.x-B.x1, pt.y-B.y1);

  corr   := libCV.MixedXCorr(worldSample, locSample);
  Result := w_ArgMax(corr);
  Result := finder.XCorrPeakNear(
    Point(Result.x*finder.scanRatio, Result.y*finder.scanRatio),
    worldMap,
    loc,
    20
  );

  Result.x := (Result.x + shift.x) - pt.x;
  Result.y := (Result.y + shift.y) - pt.y;
end;

{---| IF MEMSCAN |---]
  Updates the position of the current minimap-chuck
  This function is only executed when the minimap loads a new chunk
}
procedure TRSWalker.UpdateGlobalStart(localPt:TPoint);
var sim:Double;
begin
  if length(self.localMap) = length(finder.localMap) then
    sim := w_imCompareAt(finder.localMap, self.localMap, Point(0,0), 1);
  if sim < 1 then
  begin
    self.LocalMap := finder.LocalMap;
    self.Global := self.FindChunk(localPt);
  end;
end;

{---| IF MEMSCAN |---]
  Returns the current position of our character when using memscan
  - For normal usage use TRSWalker.GetMyPos 
}
function TRSWalker._GetPos(): TPoint;
var
  localPt:TPoint;
begin
  localPt := finder.GetLocalPos();
  self.UpdateGlobalStart(localPt);
  Result.x := localPt.x + self.Global.x;
  Result.y := localPt.y + self.Global.y;
end;

{
  Returns the current position of our character when NOT using memscan
  - For normal usage use TRSWalker.GetMyPos 
}
function TRSWalker._GetPosCustom(): TPoint;
var
  tmpMMap,Minimap,tmpLocal: T2DIntArray;
  match: T2DFloatArray;
  best: TFeaturePoint;
begin
  Minimap := RSWUtils.GetMinimap(True, False);
  tmpMMap := w_ImSample(Minimap, Finder.ScanRatio);
  match   := LibCV.MixedXCorr(WorldSample, tmpMmap);
  with w_ArgMax(match) do
  begin
    best.Value := match[X,Y];
    best.x := X * Finder.ScanRatio;
    best.y := Y * Finder.ScanRatio;
  end;

  Result := Finder.XCorrPeakNear([best.x, best.y], WorldMap, Minimap, 20);
  Result.x += Length(minimap[0]) div 2;
  Result.y += Length(minimap   ) div 2;
  Finder.Similarity := best.Value;
end;


(*
  Returns our characters current position. 
  @note: If `minSimiliarty` is set it will return (-1,-1) when it's less similar than what's expected.
*)
function TRSWalker.GetMyPos(minSimiliarty: Double = -$FFFFFFF): TPoint;
begin
  if Length(self.worldMap) = 0 then
    RaiseException('TRSWalker.GetMyPos -> RSWalker is not set up for this task!');
  
  if (finder.process > 0) and (self.memScanEnabled) then
    Result := self._GetPos()
  else
    Result := self._GetPosCustom();
  
  if (self.Finder.Similarity < minSimiliarty) then
    Exit(Point(-1,-1));
end;


(*
  Takes the position we are walking to in both it's forms:
  - mmPt (click position on minimap)
  - worldPt (goal position in the world map)
  
  Two hooks are called here:
  - onMoveEvent(self,pos)
*)
procedure TRSWalker.WalkToPos(mmPos:TPoint; Rnd:Int32=0; doRand:Boolean=False);
var
  st: Int64;
  t: TCountDown;
  pos,flag: TPoint;
  skipDist: Double;
begin
  mmPos := RotatePoint(mmPos, Minimap.GetCompassAngle(False), Minimap.Center.X, Minimap.Center.Y);
  skipDist := srl.SkewedRand(skipClose, 10, MM_RAD);
  
  if (doRand) then
    while (Rnd > 1) and (Hypot(mmPos.x-Minimap.Center.X, mmPos.y-Minimap.Center.Y) >= MM_RAD - Rnd*Sqrt(2)) do
      Dec(Rnd);

  mouse.Click(mmPos, rnd, mouse_left);
  t.Init(25000);
  repeat
    if Minimap.GetRunEnergy >= self.MinRunEnergy then 
      Minimap.ToggleRun(True);
    
    flag := [0,0];
    Minimap.FindFlag(flag);
    if Hypot(flag.X-Minimap.Center.X, flag.Y-Minimap.Center.Y) < skipDist then
      Break;

    st := GetTickCount() + Random(75);
    if Assigned(@self.onMoveEvent) then
      self.onMoveEvent(@self, pos);
    Wait( Max(1, st-GetTickCount()) );

  until (not self.Enabled) or (not Minimap.IsPlayerMoving(100)) or (t.IsFinished());
end;


(*
  Simple method to do 1 step on the minimap.
*)
function TRSWalker.WalkStep(WorldPos:TPoint; Rnd:Int32=0; WaitFlag:Boolean=True): Boolean; overload;
var
  mmPos, myPos: TPoint;
  t: TCountDown;
begin
  myPos := self.GetMyPos();
  mmPos.x := (WorldPos.x - myPos.x) + minimap.Center.X;
  mmPos.y := (WorldPos.y - myPos.y) + minimap.Center.Y;
  if (Hypot(myPos.x-myPos.x, myPos.y-myPos.y) > MM_RAD) then
    Exit(False);

  mmPos := RotatePoint(mmPos, Minimap.GetCompassAngle(False), Minimap.Center.X, Minimap.Center.Y);
  
  Mouse.Click(mmPos, Rnd, mouse_left);
  if WaitFlag then
  begin
    t.Init(25000);
    repeat
      if Minimap.GetRunEnergy >= self.minRunEnergy then 
        Minimap.ToggleRun(True);
      Wait(Random(75));
    until (not Minimap.isFlagPresent()) or t.IsFinished();
  end;
end;

(*
 Walks a path..
 
 One hook is used here:
 - onWalkEvent(self, myPos);
*)
function TRSWalker.WalkPath(Path: TPointArray; Rand:Int32=6; FinalCorrection:Boolean=False): Boolean;
var
  i,j,h,prev,tmp,attempts: Int32;
  nearest,distance: Double;
  mmPos, myPos: TPoint;
  t: TCountDown;
  
  function RandomizeRunEnergy(e:Int32):Int32;
  begin
    if e > 100 then Exit();
    Result := Random(max(5,e-10), e+10);
  end;
begin
  if Length(worldMap) = 0 then
    RaiseException('TRSWalker.WalkPath -> RSWalker is not set up for this task!');

  self.Enabled := True;
  tmp := self.MinRunEnergy;

  // get start point in path
  myPos := Self.GetMyPos();
  nearest := 100000;
  for j:=0 to High(path) do
  begin
    distance := Hypot(path[j].x-myPos.x, path[j].y-myPos.y);
    if (distance < nearest) then
    begin
      nearest := distance;
      i := j;
      if distance < MM_RAD then
        Break;
    end;
  end;

  // generate a dense path from starting point
  FPath := Copy(path, i, Length(path)-i);
  FPath := RSWUtils.BuildPath([myPos]+FPath, 6);

  // do the walk
  t.Init(Random(23000, 27000));
  FPathIdx := 0;
  H := High(FPath);
  while (FPathIdx < H) and (not t.IsFinished())  do
  begin
    self.minRunEnergy := RandomizeRunEnergy(self.minRunEnergy);
    myPos := Self.GetMyPos();
    while (FPathIdx < H) and (Hypot(myPos.x-FPath[FPathIdx+1].x, myPos.y-FPath[FPathIdx+1].y) < MM_RAD) do
      Inc(FPathIdx);

    if prev = FPathIdx then
    begin
      Inc(attempts);
      if attempts > 7 then
      begin
        self.MinRunEnergy := tmp;
        Exit(False);
      end;
    end else
      attempts := 0;

    mmPos := FPath[FPathIdx] - myPos + minimap.Center;

    if Assigned(@self.onWalkEvent) then
    begin
      self.onWalkEvent(@self, myPos);
      if not(self.enabled) then
      begin
        self.MinRunEnergy := tmp;
        Exit(True);
      end;
    end;

    self.WalkToPos(mmPos, Rand, FPathIdx<>h);
    if not(self.enabled) then
    begin
      self.MinRunEnergy := tmp;
      Exit(True);
    end;

    prev := FPathIdx;
    t.Init(Random(20000, 25000));
  end;

  Minimap.WaitPlayerMoving();
  myPos  := Self.GetMyPos();
  Result := Hypot(myPos.x-FPath[h].x, myPos.y-FPath[h].y) < 16;

  if Result and FinalCorrection then
  begin
    distance := Hypot(myPos.x-FPath[h].x, myPos.y-FPath[h].y);
    if (distance < MM_RAD) and (distance > 6) then
    begin
      mmPos.x := (FPath[h].x - myPos.x) + Minimap.Center.X;
      mmPos.y := (FPath[h].y - myPos.y) + Minimap.Center.Y;
      self.WalkToPos(mmPos, 1, True);
    end;
    Minimap.WaitPlayerMoving();
  end;

  self.minRunEnergy := tmp;
end;
